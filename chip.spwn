import "./ext.spwn"
extract import "./font.spwn"
extract import "./rom.spwn"
extract import "./util.spwn"
import core

type @quirk
impl @quirk {
    vf_reset: @bool,
    memory: @bool,
    clipping: @bool,
    shifting: @bool,
    jumping: @bool
}

default_quirks = @quirk::{
    vf_reset: true,
    memory: true,
    clipping: true,
    shifting: false,
    jumping: false
}

type @chip
impl @chip {
    ram: @array,
    vram: @array,
    v: @array,
    stk: @array,
    i: @int,
    pc: @int,
    sp: @int,
    dt: @int,
    st: @int,
    debug: @bool,
    update: @bool,
    quirk: @quirk,

    new: (debug: @bool = false) -> @chip {
        mut ram = font
        for i in 0..432 { ram.push(0) }
        for byte in rom { ram.push(byte) }
        for i in ram.length..4096 { ram.push(0) }

        mut vram = []

        for y in 0..32 {
            mut row = []
            for x in 0..64 { row.push(0) }
            vram.push(row)
        }

        mut v = []
        mut stk = []
        for i in 0..16 { v.push(0); stk.push(0) }

        ram[0x1ff] = 1

        return @chip::{
            ram: ram,
            vram: vram,
            v: v,
            stk: stk,
            i: 0,
            pc: 0x200,
            sp: 0,
            dt: 0,
            st: 0,
            debug: debug,
            update: false,
            quirk: default_quirks
        }
    },

    rw: (self, address: @int) -> @int {
        return (self.ram[address] << 8) | self.ram[address + 1]
    },

    dec_timers: (&mut self) {
        if self.dt > 0 { self.dt -= 1 }
        if self.st > 0 { self.st -= 1 }
    },

    draw: (&mut self) {
        $.print("\u{1b}[2J")

        mut canvas = []

        for y in self.vram {
            mut row = ""

            for x in y {
                row += "\u{1b}[2;47m  " if x == 1 else "\u{1b}[2;40m  "
            }

            row += "\u{1b}[0m"

            $.print(row)
        }

        $.print("\u{1b}[H")

        self.update = false
    },

    cycle: (&mut self) -> @bool {
        opcode = self.rw(self.pc)
        return self.execute(opcode)
    },

    execute: (&mut self, opcode: @int) -> @bool {
        mut fail = false
        mut instr = f"[0x{hex(self.pc)}] "

        byte = [
            (opcode & 0xf000) >> 12,
            (opcode & 0x0f00) >> 8,
            (opcode & 0x00f0) >> 4,
            opcode & 0x000f
        ]

        instr += f"({hex(byte[0])}{hex(byte[1])}{hex(byte[2])}{hex(byte[3])}) "

        n = byte[3]
        nn = opcode & 0x00ff
        nnn = opcode & 0x0fff
        x = byte[1]
        y = byte[2]

        if byte[0] == 0x0 && byte[1] == 0x0 && byte[2] == 0xe && byte[3] == 0x0 {
            instr += f"CLS"

            for y in 0..32 {
                for x in 0..64 {
                    self.vram[y][x] = 0
                }
            }
        } else if byte[0] == 0x0 && byte[1] == 0x0 && byte[2] == 0xe && byte[3] == 0xe {
            instr += "RET"
            self.pc = self.stk[self.sp]
            self.stk[self.sp] = 0
            self.sp -= 1
        } else if byte[0] == 0x1 {
            instr += f"JP 0x{hex(nnn)}"
            self.pc = nnn - 2
        } else if byte[0] == 0x2 {
            instr += f"CALL 0x{hex(nnn)}"
            self.sp += 1
            self.stk[self.sp] = self.pc
            self.pc = nnn - 2
        } else if byte[0] == 0x3 {
            instr += f"SE V{hex(x)}, 0x{hex(nn)}"
            if self.v[x] == nn { self.pc += 2 }
        } else if byte[0] == 0x4 {
            instr += f"SNE V{hex(x)}, 0x{hex(nn)}"
            if self.v[x] != nn { self.pc += 2 }
        } else if byte[0] == 0x5 {
            instr += f"SE V{hex(x)}, V{hex(y)}"
            if self.v[x] == self.v[y] { self.pc += 2 }
        } else if byte[0] == 0x6 {
            instr += f"LD V{hex(x)}, 0x{hex(nn)}"
            self.v[x] = nn
        } else if byte[0] == 0x7 {
            instr += f"ADD V{hex(x)}, 0x{hex(nn)}"
            self.v[x] += nn
        } else if byte[0] == 0x8 && byte[3] == 0x0 {
            instr += f"LD V{hex(x)}, V{hex(y)}"
            self.v[x] = self.v[y]
        } else if byte[0] == 0x8 && byte[3] == 0x1 {
            instr += f"OR V{hex(x)}, V{hex(y)}"
            if self.quirk.vf_reset { self.v[0xf] = 0 }
            self.v[x] |= self.v[y]
        } else if byte[0] == 0x8 && byte[3] == 0x2 {
            instr += f"AND V{hex(x)}, V{hex(y)}"
            if self.quirk.vf_reset { self.v[0xf] = 0 }
            self.v[x] &= self.v[y]
        } else if byte[0] == 0x8 && byte[3] == 0x3 {
            instr += f"XOR V{hex(x)}, V{hex(y)}"
            if self.quirk.vf_reset { self.v[0xf] = 0 }
            self.v[x] = self.v[x] ^ self.v[y]
        } else if byte[0] == 0x8 && byte[3] == 0x4 {
            instr += f"ADD V{hex(x)}, V{hex(y)}"
            res = self.v[x] + self.v[y]
            self.v[x] = res
            self.v[0xf] = (res > 255) as @int
        } else if byte[0] == 0x8 && byte[3] == 0x5 {
            instr += f"SUB V{hex(x)}, V{hex(y)}"
            overflow = (self.v[x] > self.v[y]) as @int
            self.v[x] = (self.v[x] - self.v[y])
            self.v[0xf] = overflow
        } else if byte[0] == 0x8 && byte[3] == 0x6 {
            instr += f"SHR V{hex(x)}, V{hex(y)}"
            lsb = self.v[x] & 1
            if self.quirk.shifting {
                self.v[x] = self.v[x] >> 1
            } else {
                self.v[x] = self.v[y] >> 1
            }
            self.v[0xf] = lsb
        } else if byte[0] == 0x8 && byte[3] == 0x7 {
            instr += f"SUBN V{hex(x)}, V{hex(y)}"
            overflow = (self.v[y] > self.v[x]) as @int
            self.v[x] = (self.v[y] - self.v[x])
            self.v[0xf] = overflow
        } else if byte[0] == 0x8 && byte[3] == 0xe {
            instr += f"SHL V{hex(x)}, V{hex(y)}"
            lsb = (self.v[x] >> 7) & 1

            if self.quirk.shifting {
                self.v[x] = self.v[x] << 1
            } else {
                self.v[x] = self.v[y] << 1
            }

            self.v[0xf] = lsb
        } else if byte[0] == 0x9 && byte[3] == 0x0 {
            instr += f"SNE V{hex(x)}, V{hex(y)}"
            if self.v[x] != self.v[y] { self.pc += 2 }
        } else if byte[0] == 0xa {
            instr += f"LD I, 0x{hex(nnn)}"
            self.i = nnn
        } else if byte[0] == 0xb {
            instr += f"JP V0, 0x{hex(nnn)}"
            if self.quirk.jumping {
                self.pc = nnn + self.v[x] - 2
            } else {
                self.pc = nnn + self.v[0] - 2
            }
        } else if byte[0] == 0xc {
            instr += f"RND V{hex(x)}, 0x{hex(nn)}"
        } else if byte[0] == 0xd {
            instr += f"DRW V{hex(x)}, V{hex(y)}, 0x{hex(n)}"

            self.v[0xf] = 0

            for byte in 0..n {
                mut yu = 0
                if self.quirk.clipping {
                    yu = (self.v[y] % 32) + byte
                } else {
                    yu = (self.v[y] + byte) % 32
                }

                if yu > 31 {
                    continue
                } else {
                    for bit in 0..8 {
                        mut xu = 0
                        if self.quirk.clipping {
                            xu = (self.v[x] % 64) + bit
                        } else {
                            xu = (self.v[x] + bit) % 64
                        }

                        if xu > 63 {
                            continue
                        } else {
                            color = (self.ram[self.i + byte] >> (7 - bit)) & 1
                            self.v[0xf] |= color & self.vram[yu][xu]
                            self.vram[yu][xu] = self.vram[yu][xu] ^ color
                        }
                    }
                }
            }

            self.update = true
        } else if byte[0] == 0xe && byte[2] == 0x9 && byte[3] == 0xe {
            instr += f"SKP V{hex(x)}"
            self.pc += 2
        } else if byte[0] == 0xe && byte[2] == 0xa && byte[3] == 0x1 {
            instr += f"SKNP V{hex(x)}"
            self.pc += 2
        } else if byte[0] == 0xf && byte[2] == 0x0 && byte[3] == 0x7 {
            instr += f"LD V{hex(x)}, DT"
            self.v[x] = self.dt
        } else if byte[0] == 0xf && byte[2] == 0x0 && byte[3] == 0xa {
            instr += f"LD V{hex(x)}, K"
        } else if byte[0] == 0xf && byte[2] == 0x1 && byte[3] == 0x5 {
            instr += f"LD DT, V{hex(x)}"
            self.dt = self.v[x]
        } else if byte[0] == 0xf && byte[2] == 0x1 && byte[3] == 0x8 {
            instr += f"LD DT, V{hex(x)}"
            self.st = self.v[x]
        } else if byte[0] == 0xf && byte[2] == 0x1 && byte[3] == 0xe {
            instr += f"ADD I, V{hex(x)}"
            self.i += self.v[x]
        } else if byte[0] == 0xf && byte[2] == 0x2 && byte[3] == 0x9 {
            instr += f"LD F, V{hex(x)}"
            self.i = self.v[x] * 5
        } else if byte[0] == 0xf && byte[2] == 0x3 && byte[3] == 0x3 {
            instr += f"LD B, V{hex(x)}"
            self.ram[self.i] = self.v[x] / 100
            self.ram[self.i + 1] = (self.v[x] % 100) / 10
            self.ram[self.i + 2] = self.v[x] % 10
        } else if byte[0] == 0xf && byte[2] == 0x5 && byte[3] == 0x5 {
            instr += f"LD [I], V{hex(x)}"

            for i in 0..x + 1 {
                self.ram[self.i + i] = self.v[i]
            }

            if self.quirk.memory { self.i += 1 }
        } else if byte[0] == 0xf && byte[2] == 0x6 && byte[3] == 0x5 {
            instr += f"LD V{hex(x)}, [I]"

            for i in 0..x + 1 {
                self.v[i] = self.ram[self.i + i]
            }

            if self.quirk.memory { self.i += 1 }
        } else {
            fail = true
            instr += f"UNKN"
        }

        for i in 0..self.v.length { self.v[i] = self.v[i].ecu_mod(256) }

        self.pc += 2

        if self.debug { $.print(instr) }

        return fail
    },
}

return {
    default_quirks: default_quirks
}